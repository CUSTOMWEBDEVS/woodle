<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Wordle Mockup</title>
  <style>
    :root{
      --bg:#121213;
      --text:#d7dadc;
      --muted:#818384;

      --absent:#3a3a3c;
      --present:#b59f3b;
      --correct:#538d4e;

      --key:#818384;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --tile-size: 58px;
      --tile-gap: 6px;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--font);
      display:flex;
      justify-content:center;
    }
    .app{
      width:min(520px, 100%);
      padding: 0 14px 18px;
      display:flex;
      flex-direction:column;
      min-height:100%;
    }

    header{
      height: 56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid #2a2a2c;
      position:sticky;
      top:0;
      background:linear-gradient(to bottom, rgba(18,18,19,.98), rgba(18,18,19,.94));
      backdrop-filter: blur(10px);
      z-index:10;
    }
    header .title{
      font-weight: 800;
      letter-spacing: 0.06em;
      font-size: 22px;
      text-transform: uppercase;
      margin:0;
      line-height:1;
    }
    header .btns{display:flex; gap:10px; align-items:center;}
    .iconbtn{
      width:38px;height:38px;
      border:none;
      border-radius: 12px;
      background: #2a2a2c;
      color: var(--text);
      display:grid;
      place-items:center;
      cursor:pointer;
    }
    .iconbtn:active{transform:translateY(1px)}
    .pill{
      font-size:12px;
      padding:8px 10px;
      border-radius: 999px;
      background:#2a2a2c;
      color: var(--text);
      border:1px solid #353538;
      display:flex;
      gap:8px;
      align-items:center;
      user-select:none;
    }
    .toggle{
      width:36px;height:20px;
      border-radius:999px;
      background:#3a3a3c;
      position:relative;
      cursor:pointer;
      border:1px solid #454547;
    }
    .toggle::after{
      content:"";
      position:absolute;
      top:2px; left:2px;
      width:16px;height:16px;
      border-radius:50%;
      background:#d7dadc;
      transition: all .18s ease;
    }
    .toggle.on{background: var(--correct); border-color: #4a7f46;}
    .toggle.on::after{left:18px; background:#fff;}

    .toast{
      position:fixed;
      top:72px;
      left:50%;
      transform:translateX(-50%);
      background:#2a2a2c;
      border:1px solid #3a3a3c;
      border-radius: 999px;
      padding:10px 14px;
      font-size:14px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      z-index:999;
      max-width: calc(100% - 24px);
      text-align:center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(0);
    }

    .board-wrap{
      display:flex;
      justify-content:center;
      padding: 18px 0 14px;
      flex: 1;
    }
    .board{
      display:grid;
      grid-template-rows: repeat(6, var(--tile-size));
      gap: var(--tile-gap);
      width: calc((var(--tile-size) * 5) + (var(--tile-gap) * 4));
    }
    .row{
      display:grid;
      grid-template-columns: repeat(5, var(--tile-size));
      gap: var(--tile-gap);
    }
    .tile{
      width: var(--tile-size);
      height: var(--tile-size);
      display:grid;
      place-items:center;
      text-transform:uppercase;
      font-weight:800;
      font-size: 28px;
      border: 2px solid #3a3a3c;
      background: transparent;
      border-radius: 6px;
      user-select:none;
      will-change: transform;
    }
    .tile.filled{ border-color:#565758; }
    .tile.absent{ background: var(--absent); border-color: var(--absent); color:#fff; }
    .tile.present{ background: var(--present); border-color: var(--present); color:#fff; }
    .tile.correct{ background: var(--correct); border-color: var(--correct); color:#fff; }

    @keyframes pop { 0%{transform:scale(.86)} 40%{transform:scale(1.08)} 100%{transform:scale(1)} }
    .tile.pop{ animation: pop .11s ease-out; }

    @keyframes shake {
      0%,100%{transform:translateX(0)}
      20%{transform:translateX(-8px)}
      40%{transform:translateX(8px)}
      60%{transform:translateX(-6px)}
      80%{transform:translateX(6px)}
    }
    .row.shake{ animation: shake .25s ease-in-out; }

    .tile.flip{ transform-style: preserve-3d; animation: flip .6s ease forwards; }
    @keyframes flip{
      0%{transform: rotateX(0deg)}
      45%{transform: rotateX(90deg)}
      55%{transform: rotateX(90deg)}
      100%{transform: rotateX(0deg)}
    }

    .kb{
      padding: 8px 0 0;
      display:flex;
      flex-direction:column;
      gap: 8px;
      align-items:center;
    }
    .kb-row{
      display:flex;
      gap: 6px;
      justify-content:center;
      width: 100%;
    }
    .key{
      height: 58px;
      min-width: 34px;
      padding: 0 10px;
      border:none;
      border-radius: 10px;
      background: var(--key);
      color: #111;
      font-weight: 800;
      cursor:pointer;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      text-transform:uppercase;
    }
    .key.wide{ min-width: 58px; padding:0 14px; }
    .key:active{ transform: translateY(1px); }
    .key.absent{ background: var(--absent); color:#fff;}
    .key.present{ background: var(--present); color:#fff;}
    .key.correct{ background: var(--correct); color:#fff;}

    .modal-backdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.6);
      display:none;
      z-index:1000;
      padding: 18px;
    }
    .modal-backdrop.show{display:flex; align-items:center; justify-content:center;}
    .modal{
      width:min(520px, 100%);
      background: #1a1a1b;
      border:1px solid #2a2a2c;
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal header{
      position:relative;
      top:auto;
      background:transparent;
      border-bottom:1px solid #2a2a2c;
      padding: 0 12px;
    }
    .modal .content{
      padding: 14px 14px 16px;
      font-size: 14px;
      line-height: 1.45;
    }
    .modal .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin-top: 12px;
    }
    .stat{
      background:#111112;
      border:1px solid #2a2a2c;
      border-radius: 12px;
      padding: 10px;
      text-align:center;
    }
    .stat .n{font-size:22px; font-weight:900;}
    .stat .l{font-size:12px; color: var(--muted);}
    .modal .actions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      padding: 0 14px 14px;
    }
    .btn{
      border:none;
      border-radius: 12px;
      padding: 12px 14px;
      font-weight:900;
      cursor:pointer;
      background:#2a2a2c;
      color: var(--text);
      border:1px solid #353538;
    }
    .btn.primary{
      background: var(--correct);
      border-color: #4a7f46;
      color:#fff;
    }

    @media (max-width: 390px){
      :root{ --tile-size: 52px; }
      .key{ height:54px; }
      header .title{ font-size:20px; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="btns">
      <button class="iconbtn" id="btnHelp" aria-label="Help">?</button>
      <button class="iconbtn" id="btnStats" aria-label="Stats">â˜…</button>
    </div>

    <h1 class="title">Wordle</h1>

    <div class="btns">
      <div class="pill" title="Daily Mode (same word all day)">
        DAILY
        <div class="toggle" id="dailyToggle" role="switch" aria-checked="false"></div>
      </div>
      <div class="pill" title="Hard Mode">
        HARD
        <div class="toggle" id="hardToggle" role="switch" aria-checked="false"></div>
      </div>
      <button class="iconbtn" id="btnNewGame" aria-label="New Game">â†»</button>
    </div>
  </header>

  <div class="board-wrap">
    <div class="board" id="board"></div>
  </div>

  <div class="kb" id="keyboard"></div>
</div>

<div class="toast" id="toast"></div>

<div class="modal-backdrop" id="helpModal">
  <div class="modal" role="dialog" aria-modal="true">
    <header>
      <div style="display:flex; align-items:center; justify-content:space-between; width:100%;">
        <strong>How to play</strong>
        <button class="iconbtn" id="closeHelp" aria-label="Close">âœ•</button>
      </div>
    </header>
    <div class="content">
      Guess the <b>5-letter word</b> in <b>6 tries</b>.<br/>
      DAILY mode = same answer all day. OFF = random practice mode.
      <p style="margin:10px 0 0; color:var(--muted);">
        If word lists fail to load, donâ€™t open as <code>file://</code>. Use a local server or host it.
      </p>
    </div>
  </div>
</div>

<div class="modal-backdrop" id="statsModal">
  <div class="modal" role="dialog" aria-modal="true">
    <header>
      <div style="display:flex; align-items:center; justify-content:space-between; width:100%;">
        <strong>Stats</strong>
        <button class="iconbtn" id="closeStats" aria-label="Close">âœ•</button>
      </div>
    </header>
    <div class="content">
      <div class="grid">
        <div class="stat"><div class="n" id="stPlayed">0</div><div class="l">Played</div></div>
        <div class="stat"><div class="n" id="stWin">0</div><div class="l">Win %</div></div>
        <div class="stat"><div class="n" id="stStreak">0</div><div class="l">Current Streak</div></div>
        <div class="stat"><div class="n" id="stMax">0</div><div class="l">Max Streak</div></div>
      </div>
      <div style="margin-top:12px; color:var(--muted); font-size:12px;">
        Share uses emoji squares.
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnCopyShare">Copy Share</button>
      <button class="btn primary" id="btnCloseStats2">Done</button>
    </div>
  </div>
</div>

<script>
(() => {
  const WORD_LENGTH = 5;
  const MAX_GUESSES = 6;

  // Public classic Wordle lists (remote)
  const SOLUTIONS_URL = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt";
  const ALLOWED_URL   = "https://gist.githubusercontent.com/cfreshman/cdcdf777450c5b5301e439061d29694c/raw/wordle-allowed-guesses.txt";

  const LS_STATE = "wordle_mock_state_v3";
  const LS_STATS = "wordle_mock_stats_v3";
  const LS_HARD  = "wordle_mock_hard_v3";
  const LS_DAILY = "wordle_mock_daily_v3";

  const EMOJI = { correct:"ðŸŸ©", present:"ðŸŸ¨", absent:"â¬›" };
  const KEY_ROWS = ["qwertyuiop","asdfghjkl","zxcvbnm"];

  const boardEl = document.getElementById("board");
  const kbEl = document.getElementById("keyboard");
  const toastEl = document.getElementById("toast");

  const helpModal = document.getElementById("helpModal");
  const statsModal = document.getElementById("statsModal");

  const btnHelp = document.getElementById("btnHelp");
  const btnStats = document.getElementById("btnStats");
  const btnNewGame = document.getElementById("btnNewGame");
  const closeHelp = document.getElementById("closeHelp");
  const closeStats = document.getElementById("closeStats");
  const btnCloseStats2 = document.getElementById("btnCloseStats2");
  const btnCopyShare = document.getElementById("btnCopyShare");

  const hardToggle = document.getElementById("hardToggle");
  const dailyToggle = document.getElementById("dailyToggle");

  const stPlayed = document.getElementById("stPlayed");
  const stWin = document.getElementById("stWin");
  const stStreak = document.getElementById("stStreak");
  const stMax = document.getElementById("stMax");

  function showToast(msg, ms=1200){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove("show"), ms);
  }
  function openModal(el){ el.classList.add("show"); }
  function closeModal(el){ el.classList.remove("show"); }

  function todayKey(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }

  function normalizeWord(w){ return (w||"").trim().toLowerCase(); }
  function isAlphaWord(w){ return /^[a-z]{5}$/.test(w); }

  // deterministic RNG
  function mulberry32(seed){
    return function(){
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function hash32(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function scoreGuess(guess, answer){
    guess = guess.toLowerCase();
    answer = answer.toLowerCase();
    const result = Array(WORD_LENGTH).fill("absent");
    const counts = {};
    for (let i=0;i<WORD_LENGTH;i++){
      if (guess[i] === answer[i]) result[i] = "correct";
      else counts[answer[i]] = (counts[answer[i]] || 0) + 1;
    }
    for (let i=0;i<WORD_LENGTH;i++){
      if (result[i] === "correct") continue;
      const ch = guess[i];
      if (counts[ch] > 0){
        result[i] = "present";
        counts[ch]--;
      }
    }
    return result;
  }

  function betterKeyState(a, b){
    const rank = { correct:3, present:2, absent:1, none:0 };
    return rank[b] > rank[a] ? b : a;
  }

  function hardModeCheck(nextGuess, history){
    const mustPos = Array(WORD_LENGTH).fill(null);
    const minCounts = {};

    for (const h of history){
      const g = h.guess;
      const s = h.score;
      for (let i=0;i<WORD_LENGTH;i++){
        if (s[i] === "correct") mustPos[i] = g[i];
      }
      const local = {};
      for (let i=0;i<WORD_LENGTH;i++){
        if (s[i] === "present" || s[i] === "correct"){
          local[g[i]] = (local[g[i]] || 0) + 1;
        }
      }
      for (const k in local){
        minCounts[k] = Math.max(minCounts[k] || 0, local[k]);
      }
    }

    for (let i=0;i<WORD_LENGTH;i++){
      if (mustPos[i] && nextGuess[i] !== mustPos[i]){
        return `Hard Mode: ${mustPos[i].toUpperCase()} must be in position ${i+1}`;
      }
    }
    const counts = {};
    for (const ch of nextGuess) counts[ch] = (counts[ch]||0) + 1;
    for (const k in minCounts){
      if ((counts[k]||0) < minCounts[k]){
        return `Hard Mode: guess must contain ${k.toUpperCase()} (${minCounts[k]}+)`;
      }
    }
    return null;
  }

  // Lists
  let SOLUTIONS = [];
  let ALLOWED_SET = new Set();

  async function fetchWordFile(url){
    const res = await fetch(url, { cache: "no-cache" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    return text.split(/\r?\n/).map(normalizeWord).filter(isAlphaWord);
  }

  async function loadLists(){
    const [solutions, allowed] = await Promise.all([
      fetchWordFile(SOLUTIONS_URL),
      fetchWordFile(ALLOWED_URL)
    ]);
    SOLUTIONS = solutions;
    ALLOWED_SET = new Set(allowed);
    for (const w of SOLUTIONS) ALLOWED_SET.add(w);
    showToast(`Loaded ${SOLUTIONS.length.toLocaleString()} solutions / ${ALLOWED_SET.size.toLocaleString()} valid`, 1600);
  }

  function pickDailyAnswer(solutions, dateKeyStr){
    const baseSeed = 0xC0FFEE ^ hash32("wordle-daily-seed-v3");
    const rng = mulberry32(baseSeed);
    const arr = solutions.slice();
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(rng() * (i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    const epoch = new Date(2021,0,1);
    const d = new Date(dateKeyStr + "T00:00:00");
    const dayIndex = Math.floor((d - epoch)/(1000*60*60*24));
    const idx = ((dayIndex % arr.length) + arr.length) % arr.length;
    return { answer: arr[idx], dayIndex };
  }

  function pickRandomAnswer(solutions){
    const x = new Uint32Array(1);
    crypto.getRandomValues(x);
    const idx = x[0] % solutions.length;
    return solutions[idx];
  }

  const state = {
    dateKey: todayKey(),
    answer: "",
    dayIndex: 0,
    guesses: [],
    current: "",
    row: 0,
    col: 0,
    done: false,
    won: false,
    hard: false,
    dailyMode: false,   // NEW: daily vs random
    gameId: ""          // NEW: for random mode uniqueness
  };

  const stats = { played:0, wins:0, currentStreak:0, maxStreak:0 };

  function buildBoard(){
    boardEl.innerHTML = "";
    for (let r=0;r<MAX_GUESSES;r++){
      const row = document.createElement("div");
      row.className = "row";
      row.dataset.row = String(r);
      for (let c=0;c<WORD_LENGTH;c++){
        const tile = document.createElement("div");
        tile.className = "tile";
        tile.dataset.row = String(r);
        tile.dataset.col = String(c);
        row.appendChild(tile);
      }
      boardEl.appendChild(row);
    }
  }

  function buildKeyboard(){
    kbEl.innerHTML = "";
    const row1 = document.createElement("div"); row1.className="kb-row";
    for (const ch of KEY_ROWS[0]) row1.appendChild(makeKey(ch));
    const row2 = document.createElement("div"); row2.className="kb-row";
    for (const ch of KEY_ROWS[1]) row2.appendChild(makeKey(ch));
    const row3 = document.createElement("div"); row3.className="kb-row";
    row3.appendChild(makeKey("enter", true));
    for (const ch of KEY_ROWS[2]) row3.appendChild(makeKey(ch));
    row3.appendChild(makeKey("back", true));
    kbEl.appendChild(row1); kbEl.appendChild(row2); kbEl.appendChild(row3);
  }

  function makeKey(label, wide=false){
    const btn = document.createElement("button");
    btn.className = "key" + (wide ? " wide" : "");
    btn.type = "button";
    btn.dataset.key = label;
    btn.textContent = (label === "back") ? "âŒ«" : label;
    btn.addEventListener("click", () => handleKey(label));
    return btn;
  }

  function getTile(r,c){ return boardEl.querySelector(`.tile[data-row="${r}"][data-col="${c}"]`); }
  function getRowEl(r){ return boardEl.querySelector(`.row[data-row="${r}"]`); }

  function paintCurrentRow(){
    const r = state.row;
    for (let c=0;c<WORD_LENGTH;c++){
      const t = getTile(r,c);
      const ch = state.current[c] || "";
      t.textContent = ch ? ch.toUpperCase() : "";
      t.classList.toggle("filled", !!ch);
    }
  }

  function applyHistoryToBoard(){
    for (let r=0;r<MAX_GUESSES;r++){
      for (let c=0;c<WORD_LENGTH;c++){
        const t = getTile(r,c);
        t.textContent = "";
        t.className = "tile";
      }
    }
    state.guesses.forEach((g, r) => {
      for (let c=0;c<WORD_LENGTH;c++){
        const t = getTile(r,c);
        t.textContent = g.guess[c].toUpperCase();
        t.classList.add(g.score[c]);
        t.classList.add("filled");
      }
    });
    paintCurrentRow();
    updateKeyboardColors();
  }

  function updateKeyboardColors(){
    const keyState = {};
    for (const g of state.guesses){
      for (let i=0;i<WORD_LENGTH;i++){
        const ch = g.guess[i];
        keyState[ch] = betterKeyState(keyState[ch] || "none", g.score[i]);
      }
    }
    document.querySelectorAll(".key").forEach(k => {
      const raw = k.dataset.key;
      if (!raw || raw === "enter" || raw === "back") return;
      k.classList.remove("absent","present","correct");
      const s = keyState[raw];
      if (s && s !== "none") k.classList.add(s);
    });
  }

  function loadStats(){
    try{
      const raw = localStorage.getItem(LS_STATS);
      if (!raw) return;
      Object.assign(stats, JSON.parse(raw) || {});
    }catch{}
  }
  function saveStats(){ localStorage.setItem(LS_STATS, JSON.stringify(stats)); }

  function loadHard(){
    const v = localStorage.getItem(LS_HARD);
    state.hard = (v === "1");
    hardToggle.classList.toggle("on", state.hard);
    hardToggle.setAttribute("aria-checked", state.hard ? "true" : "false");
  }
  function saveHard(){ localStorage.setItem(LS_HARD, state.hard ? "1" : "0"); }

  function loadDailyMode(){
    const v = localStorage.getItem(LS_DAILY);
    state.dailyMode = (v === "1");
    dailyToggle.classList.toggle("on", state.dailyMode);
    dailyToggle.setAttribute("aria-checked", state.dailyMode ? "true" : "false");
  }
  function saveDailyMode(){ localStorage.setItem(LS_DAILY, state.dailyMode ? "1" : "0"); }

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_STATE);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (!obj) return;

      // If DAILY mode: only restore if it's today's daily
      if (obj.dailyMode){
        if (obj.dateKey !== state.dateKey) return;
        Object.assign(state, obj);
        return;
      }

      // If RANDOM mode: restore latest random game (no date restriction)
      Object.assign(state, obj);
    }catch{}
  }

  function saveState(){
    const payload = {
      dateKey: state.dateKey,
      answer: state.answer,
      dayIndex: state.dayIndex,
      guesses: state.guesses,
      current: state.current,
      row: state.row,
      col: state.col,
      done: state.done,
      won: state.won,
      hard: state.hard,
      dailyMode: state.dailyMode,
      gameId: state.gameId
    };
    localStorage.setItem(LS_STATE, JSON.stringify(payload));
  }

  function rowShake(r){
    const rowEl = getRowEl(r);
    if (!rowEl) return;
    rowEl.classList.remove("shake");
    void rowEl.offsetWidth;
    rowEl.classList.add("shake");
  }

  async function revealRowFlip(r, scored){
    for (let c=0;c<WORD_LENGTH;c++){
      const t = getTile(r,c);
      t.classList.add("flip");
      setTimeout(() => {
        t.classList.add(scored[c]);
        updateKeyboardColors();
      }, 300);
      await new Promise(res => setTimeout(res, 90));
    }
    setTimeout(() => {
      for (let c=0;c<WORD_LENGTH;c++){
        getTile(r,c).classList.remove("flip");
      }
    }, 700);
  }

  function startDailyGame(){
    state.dailyMode = true;
    state.dateKey = todayKey();
    const daily = pickDailyAnswer(SOLUTIONS, state.dateKey);
    state.answer = daily.answer;
    state.dayIndex = daily.dayIndex;
    state.gameId = `daily:${state.dateKey}`;
    resetBoardOnly(false);
  }

  function startRandomGame(){
    state.dailyMode = false;
    state.dateKey = todayKey();
    state.answer = pickRandomAnswer(SOLUTIONS);
    state.dayIndex = 0;
    state.gameId = `rand:${Date.now()}:${Math.random().toString(16).slice(2)}`;
    resetBoardOnly(false);
  }

  function resetBoardOnly(showMsg=true){
    state.guesses = [];
    state.current = "";
    state.row = 0;
    state.col = 0;
    state.done = false;
    state.won = false;
    saveState();
    applyHistoryToBoard();
    if (showMsg) showToast("New game");
  }

  async function submitGuess(){
    const guess = normalizeWord(state.current);

    if (guess.length !== WORD_LENGTH){
      showToast("Not enough letters");
      rowShake(state.row);
      return;
    }
    if (!ALLOWED_SET.has(guess)){
      showToast("Not in word list");
      rowShake(state.row);
      return;
    }
    if (state.hard && state.guesses.length > 0){
      const err = hardModeCheck(guess, state.guesses);
      if (err){
        showToast(err, 1400);
        rowShake(state.row);
        return;
      }
    }

    const scored = scoreGuess(guess, state.answer);
    const rowIndex = state.row;

    state.guesses.push({ guess, score: scored });
    state.current = "";
    state.row++;
    state.col = 0;
    saveState();

    for (let c=0;c<WORD_LENGTH;c++){
      const t = getTile(rowIndex,c);
      t.textContent = guess[c].toUpperCase();
      t.classList.add("filled");
    }

    await revealRowFlip(rowIndex, scored);

    if (guess === state.answer){
      state.done = true;
      state.won = true;
      finalizeGame(true);
      showToast("Nice");
      saveState();
      setTimeout(openStats, 650);
      return;
    }

    if (state.guesses.length >= MAX_GUESSES){
      state.done = true;
      state.won = false;
      finalizeGame(false);
      showToast(`The word was ${state.answer.toUpperCase()}`, 4000);
      saveState();
      setTimeout(openStats, 650);
      return;
    }

    paintCurrentRow();
  }

  function finalizeGame(won){
    // Only track streaks for DAILY mode (like real Wordle)
    if (!state.dailyMode) return;

    const markKey = `wordle_mock_mark_${state.dateKey}`;
    if (localStorage.getItem(markKey) === "1") return;
    localStorage.setItem(markKey, "1");

    stats.played++;
    if (won){
      stats.wins++;
      stats.currentStreak++;
      stats.maxStreak = Math.max(stats.maxStreak, stats.currentStreak);
    } else {
      stats.currentStreak = 0;
    }
    saveStats();
  }

  function refreshStatsUI(){
    const winPct = stats.played ? Math.round((stats.wins / stats.played) * 100) : 0;
    stPlayed.textContent = String(stats.played);
    stWin.textContent = String(winPct);
    stStreak.textContent = String(stats.currentStreak);
    stMax.textContent = String(stats.maxStreak);
  }
  function openStats(){
    refreshStatsUI();
    openModal(statsModal);
  }

  function getShareText(){
    const score = state.won ? state.guesses.length : "X";
    const label = state.dailyMode ? `Wordle ${state.dayIndex}` : `Wordle (Practice)`;
    let out = `${label} ${score}/${MAX_GUESSES}\n\n`;
    for (const g of state.guesses){
      out += g.score.map(s => EMOJI[s]).join("") + "\n";
    }
    return out.trim();
  }
  async function copyShare(){
    const text = getShareText();
    try{
      await navigator.clipboard.writeText(text);
      showToast("Copied to clipboard");
    }catch{
      window.prompt("Copy share text:", text);
    }
  }

  function handleKey(key){
    if (state.done) return;
    if (key === "enter") return submitGuess();
    if (key === "back"){
      if (state.current.length > 0){
        state.current = state.current.slice(0, -1);
        state.col = state.current.length;
        paintCurrentRow();
        saveState();
      }
      return;
    }
    if (/^[a-z]$/.test(key)){
      if (state.current.length >= WORD_LENGTH) return;
      state.current += key;
      state.col = state.current.length;
      const t = getTile(state.row, state.col-1);
      if (t){
        t.classList.add("pop");
        setTimeout(() => t.classList.remove("pop"), 120);
      }
      paintCurrentRow();
      saveState();
    }
  }

  function buildBoard(){
    boardEl.innerHTML = "";
    for (let r=0;r<MAX_GUESSES;r++){
      const row = document.createElement("div");
      row.className = "row";
      row.dataset.row = String(r);
      for (let c=0;c<WORD_LENGTH;c++){
        const tile = document.createElement("div");
        tile.className = "tile";
        tile.dataset.row = String(r);
        tile.dataset.col = String(c);
        row.appendChild(tile);
      }
      boardEl.appendChild(row);
    }
  }

  function buildKeyboard(){
    kbEl.innerHTML = "";
    const row1 = document.createElement("div"); row1.className="kb-row";
    for (const ch of KEY_ROWS[0]) row1.appendChild(makeKey(ch));
    const row2 = document.createElement("div"); row2.className="kb-row";
    for (const ch of KEY_ROWS[1]) row2.appendChild(makeKey(ch));
    const row3 = document.createElement("div"); row3.className="kb-row";
    row3.appendChild(makeKey("enter", true));
    for (const ch of KEY_ROWS[2]) row3.appendChild(makeKey(ch));
    row3.appendChild(makeKey("back", true));
    kbEl.appendChild(row1); kbEl.appendChild(row2); kbEl.appendChild(row3);
  }
  function makeKey(label, wide=false){
    const btn = document.createElement("button");
    btn.className = "key" + (wide ? " wide" : "");
    btn.type = "button";
    btn.dataset.key = label;
    btn.textContent = (label === "back") ? "âŒ«" : label;
    btn.addEventListener("click", () => handleKey(label));
    return btn;
  }

  // Events
  window.addEventListener("keydown", (e) => {
    if (helpModal.classList.contains("show") || statsModal.classList.contains("show")){
      if (e.key === "Escape"){
        closeModal(helpModal);
        closeModal(statsModal);
      }
      return;
    }
    const k = e.key.toLowerCase();
    if (k === "enter") return handleKey("enter");
    if (k === "backspace") return handleKey("back");
    if (/^[a-z]$/.test(k)) return handleKey(k);
  });

  btnHelp.addEventListener("click", () => openModal(helpModal));
  closeHelp.addEventListener("click", () => closeModal(helpModal));
  helpModal.addEventListener("click", (e) => { if (e.target === helpModal) closeModal(helpModal); });

  btnStats.addEventListener("click", openStats);
  closeStats.addEventListener("click", () => closeModal(statsModal));
  btnCloseStats2.addEventListener("click", () => closeModal(statsModal));
  statsModal.addEventListener("click", (e) => { if (e.target === statsModal) closeModal(statsModal); });
  btnCopyShare.addEventListener("click", copyShare);

  hardToggle.addEventListener("click", () => {
    state.hard = !state.hard;
    hardToggle.classList.toggle("on", state.hard);
    hardToggle.setAttribute("aria-checked", state.hard ? "true" : "false");
    saveHard();
    saveState();
    showToast(state.hard ? "Hard Mode on" : "Hard Mode off");
  });

  dailyToggle.addEventListener("click", () => {
    state.dailyMode = !state.dailyMode;
    dailyToggle.classList.toggle("on", state.dailyMode);
    dailyToggle.setAttribute("aria-checked", state.dailyMode ? "true" : "false");
    saveDailyMode();

    // switching modes starts a fresh game in that mode
    if (state.dailyMode) startDailyGame();
    else startRandomGame();

    saveState();
    showToast(state.dailyMode ? "Daily mode" : "Practice mode");
  });

  // NEW GAME button: now actually changes the answer
  btnNewGame.addEventListener("click", () => {
    if (state.dailyMode) startDailyGame();   // resets to today's daily
    else startRandomGame();                  // new random word every click
    saveState();
  });

  async function init(){
    buildBoard();
    buildKeyboard();

    loadStats();
    loadHard();
    loadDailyMode();

    try{
      await loadLists();
    }catch (err){
      console.error(err);
      showToast("Failed to load word lists. Use Live Server / http.server", 2600);
      SOLUTIONS = ["crane","slate","stare","trace","cigar"];
      ALLOWED_SET = new Set(SOLUTIONS);
    }

    // Restore last game state if possible
    loadState();

    // If nothing usable loaded, start fresh in current mode
    if (!state.answer || !ALLOWED_SET.size){
      if (state.dailyMode) startDailyGame();
      else startRandomGame();
    } else {
      // ensure toggle UI matches loaded state
      dailyToggle.classList.toggle("on", state.dailyMode);
      dailyToggle.setAttribute("aria-checked", state.dailyMode ? "true" : "false");
      hardToggle.classList.toggle("on", state.hard);
      hardToggle.setAttribute("aria-checked", state.hard ? "true" : "false");
      applyHistoryToBoard();
    }
  }

  init();
})();
</script>
</body>
</html>
